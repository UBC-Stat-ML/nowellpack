package humi.v8

import humi.HumiData
import humi.IntMixture
import humi.Monitor

model MixYS { 
  param HumiData data
  param Plated<IntVar> initialPopCounts
  random Plated<RealVar> rho1s, rho2s
  random Plated<DenseSimplex> pis ?: Plated::latent("pis", [latentSimplex(2)])
    
  random Plated<RealVar> lambdas
    
  random Plated<Monitor> visibleCloneNumbers, truncatedMeans
  
  param RealVar vagueRate ?: 0.01
  
  laws {
    
    for (Index<String> experiment : data.experiments.indices) {
      lambdas.get(experiment) | vagueRate ~ Exponential(vagueRate)
    }
        
    for (Index<Integer> target : data.targets.indices.filter[key == 8]) {
      
      pis.get(target) ~ SimplexUniform(2)
      rho1s.get(target) | vagueRate ~ Exponential(vagueRate)
      rho2s.get(target) | vagueRate ~ Exponential(vagueRate)
       
      for (Index<String> experiment : data.experiments.indices(target)) {
        data.histograms.get(target, experiment) |
          RealVar lambda = lambdas.get(experiment), 
          IntVar initialPopCount = initialPopCounts.get(target),
          IntDistribution dist = {
            val pi = pis.get(target)
            val rho1 = rho1s.get(target)
            val rho2 = rho2s.get(target)
            val lambda = lambdas.get(experiment)
            val initialPopCount = initialPopCounts.get(target)
            val result = IntMixture::distribution(pi, #[ 
                YuleSimon::distribution(rho1), 
                YuleSimon::distribution(rho2)
              ]
            )
            
            // register visible clone number monitors
            visibleCloneNumbers.get(target, DistributionSummary::modelIndex).init[
              val p0 = Math.exp(result.logDensity(0))
              return (1.0 - p0) * initialPopCount * lambda
            ]
            val observedHist = data.histograms.get(target, experiment)
            val dataVisibleCloneNumbers = observedHist.nDataPoints
            visibleCloneNumbers.get(target, DistributionSummary::dataIndex).init[dataVisibleCloneNumbers]
            
            // register truncated mean monitors
            truncatedMeans.get(target, DistributionSummary::modelIndex).init[
              DistributionSummary::mean(DistributionSummary::truncatedNormalizedCounter(result))
            ]
            val dataCloneTM = DistributionSummary::mean(DistributionSummary::truncatedNormalizedCounter(observedHist))
            truncatedMeans.get(target, DistributionSummary::dataIndex).init[ dataCloneTM ]
            
            return result
          }
        ~ CensoredExchangeableCounts(dist, initialPopCount * lambda)   
      }   
    }
  }
}