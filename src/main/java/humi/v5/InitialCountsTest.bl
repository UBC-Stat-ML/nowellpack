package humi.v5

model InitialCountsTest {
  
  param Plate<Integer> sgRNA
  random Plated<IntVar> counts1, counts2
  random Plated<IntVar> indicators
  
  random DenseSimplex 
    relativeRate ?: latentSimplex(2)
  
  random RealVar 
    alpha ?: latentReal, 
    beta  ?: latentReal
  
  random DenseSimplex pi ?: latentSimplex(2)
  
  laws {
    
    pi ~ SimplexUniform(2)
    
    alpha ~ Exponential(0.001)
    beta ~ Exponential(0.001)
    
    relativeRate ~ SimplexUniform(2)
    
    for (Index<Integer> sgrna : sgRNA.indices) {
      
      indicators.get(sgrna) | pi ~ Categorical(pi)
      
      | 
        alpha, beta,
        relativeRate,
        IntVar indic = indicators.get(sgrna),
        IntVar count1 = counts1.get(sgrna), 
        IntVar count2 = counts2.get(sgrna) ~ LogPotential({
          val rate1 = relativeRate.get(0)
          val rate2 = relativeRate.get(1)
          if (alpha <= 0.0 || beta <= 0.0 || rate1 <= 0.0 || rate2 <= 0.0) return NEGATIVE_INFINITY
          if (indic != 0 && indic != 1) return NEGATIVE_INFINITY
          val priorNorm = alpha * log(beta) - logGamma(alpha)
          val commonTerms = - logFactorial(count1) - logFactorial(count2) + count1 * log(rate1) + count2 * log(rate2)
          // using shared
          val m0 =       priorNorm + commonTerms + logGamma(alpha + count1 + count2) - (alpha + count1 + count2) * log(beta + rate1 + rate2)
          // using separate
          val m1 = 2.0 * priorNorm + commonTerms + logGamma(alpha + count1)          - (alpha + count1) *          log(beta + rate1) +
                                                   logGamma(alpha + count2)          - (alpha + count2) *          log(beta + rate2)
          return if (indic == 1) m1 else m0
        })
    }
  }
}