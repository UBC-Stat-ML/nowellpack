package humi.v5

import humi.HumiData
import humi.IntMixture

model M_5_3 { 
  param HumiData data
  param Plated<IntVar> initialPopCounts
  random Plated<RealVar> thinnedUMIRates, rho1s
//  random RealVar initCountShape ?: latentReal, initCountRate ?: latentReal
//  random DenseSimplex initialCountDefectivePr ?: latentSimplex(2)
  random RealVar 
//    a ?: latentReal, 
//    b ?: latentReal, 
//    c ?: latentReal, 
//    d ?: latentReal, 
//    e ?: latentReal, 
//    f ?: latentReal,
//    g ?: latentReal,
//    h ?: latentReal,
    rho2 ?: latentReal

  param RealVar initialUMICoverage ?: fixedReal(0.5) 
    
  random PlatedMatrix rateMultipliers
  random DenseSimplex  pi ?: latentSimplex(2)
  param RealVar vagueRate ?: 0.001
  
  laws {
    
//    initialCountDefectivePr ~ SimplexUniform(2)
//    initCountShape | vagueRate ~ Exponential(vagueRate)
//    initCountRate | vagueRate ~ Exponential(vagueRate)
//    a | vagueRate ~ Exponential(vagueRate)
//    b | vagueRate ~ Exponential(vagueRate)
//    c | vagueRate ~ Exponential(vagueRate)
//    d | vagueRate ~ Exponential(vagueRate)
//    e | vagueRate ~ Exponential(vagueRate)
//    f | vagueRate ~ Exponential(vagueRate)
//    g | vagueRate ~ Exponential(vagueRate)
//    h | vagueRate ~ ContinuousUniform(0, 1)
    
    rateMultipliers.getDenseSimplex(data.experiments) | int size = data.experiments.indices.size ~ SimplexUniform(size)
    
    pi ~ Dirichlet(denseCopy(#[1.0, 1.0])) 
    rho2 ~ ContinuousUniform(0.0, 2.0) 
    
    for (Index<Integer> target : data.targets.indices) {
      
      // robust initial count modelling
      thinnedUMIRates.get(target) | vagueRate ~ Exponential(vagueRate) //initCountShape, initCountRate ~ Gamma(initCountShape, initCountRate)
      initialPopCounts.get(target) | 
//      initialCountDefectivePr, initCountShape, initCountRate, 
      RealVar thinnedUMIRate = thinnedUMIRates.get(target)
        ~ Poisson(thinnedUMIRate)
//        ~ IntMixture(initialCountDefectivePr, #[
//          Poisson::distribution(thinnedUMIRate),
//          NegativeBinomial::distribution(g, h)
//        ])
        
      rho1s.get(target) | vagueRate ~ Exponential(vagueRate)
       
      for (Index<String> experiment : data.experiments.indices(target)) {
        // final counts likelihood
        data.histograms.get(target, experiment) |
          RealVar rho1 = rho1s.get(target),
          rho2, pi, initialUMICoverage,
          RealVar rateMultiplier = rateMultipliers.getDenseSimplexEntry(data.experiments, experiment), 
          double nExperiments = data.experiments.indices.size,
          RealVar thinnedUMIRate = thinnedUMIRates.get(target)
        ~ CensoredExchangeableCounts(
          {
            IntMixture::distribution(
              pi, 
              #[ // Warning: if edited, need to change M_5_Postprocess
                YuleSimon::distribution(rho1), 
                YuleSimon::distribution(rho2)
              ]
            )
          }, 
          thinnedUMIRate * (nExperiments*rateMultiplier) / initialUMICoverage
        )  
      }   
    }
  }
}



//      | thinning, initialCountDefectivePr, initCountShape, initCountRate, IntVar initCount = initialPopCounts.get(target)
//      ~ LogPotential({
//        if (initialCountDefectivePr < 0.0 || initialCountDefectivePr > 1.0) return NEGATIVE_INFINITY
//        if (thinning < 0.0 || thinning > 1.0) return NEGATIVE_INFINITY
//        val outlierLogPr = log(initialCountDefectivePr) + Double.NaN
//        val regularLogPr = log1p(- initialCountDefectivePr) + Poisson::distribution(Double.NaN).logDensity(initCount)
//        return NumericalUtils::logAdd(outlierLogPr, regularLogPr)
//      })